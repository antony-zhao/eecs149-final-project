target C {
    threading: false,
    build: "../scripts/build_nrf_unix.sh"   
};

import Display from "lib/Display.lf"

preamble {=
    #include "simple_ble.h"

    // Data structures needed for BLE.
    // See https://github.com/lab11/nrf52x-base/blob/master/lib/simple_ble/README.md

    // BLE Configuration specifies the MAC address and
    // intervals for advertising and connections.
    static simple_ble_config_t ble_config = {
            // MAC address: c0:98:e5:49:xx:xx
            // where the last two octets are given by the device_id below.
            .platform_id       = 0x49,   // The 4th octet in device BLE address.
            .device_id         = 0xAABB, // TODO: replace with your lab bench number
            .adv_name          = "ROMI", // used in advertisements if there is room
            .adv_interval      = MSEC_TO_UNITS(100, UNIT_0_625_MS),
            .min_conn_interval = MSEC_TO_UNITS(100, UNIT_1_25_MS),
            .max_conn_interval = MSEC_TO_UNITS(200, UNIT_1_25_MS),
    };

    // Specify a unique ID for the ROMI service.
    // UUID: 85e43f4d-b4a7-4c6f-ba86-2db3c40a2c83
    static simple_ble_service_t romi_service = {{
        .uuid128 = {0x83,0x2c,0x0a,0xc4,0xb3,0x2d,0x86,0xba,
                    0x6f,0x4c,0xa7,0xb4,0x4d,0x3f,0xe4,0x85}
    }};

    // Characteristic reflecting key presses.
    // The characteristic is identified within the service by a 16-bit unique ID.
    static simple_ble_char_t key_state_characteristic = {.uuid16 = 0x7182};

    static bool inputs[6] = {false, false, false, false, false, false};
=}

/**
 * This reactor, designed to run on an nRF52 board, advertises
 * itself during startup and adds a Bluetooth service with a
 * characteristic that receives arrow key information from a
 * computer that pairs with the nRF52. It then periodically
 * outputs four booleans indicating whether each particular
 * arrow key is currently pressed.  The period is given as
 * a parameter.
 */
reactor BluetoothReactor(period:time(100 ms)) {

    output s1:bool;
    output s2:bool;
    output s3:bool;
    output s4:bool;
    output s5:bool;
    output s6:bool;

    timer t(0, period);

    reaction(startup) {=
        // Set up BLE.
        // See https://github.com/lab11/nrf52x-base/blob/master/lib/simple_ble/README.md
        simple_ble_app_t * simple_ble_app = simple_ble_init(&ble_config);
        
        simple_ble_add_service(&romi_service);

        simple_ble_add_characteristic(1, 1, 0, 0, sizeof(keys), (uint8_t*)&keys, &romi_service, &key_state_characteristic);

        simple_ble_adv_only_name();
        // Your code goes here.
    =}

    reaction(t) -> s1, s2, s3, s4, s5, s6 {=
        // Output a boolean for each arrow key, where true
        // indicates that the key is currently pressed and false
        // indicates that it is not.

        // Your code goes here.
        lf_set(s1, keys[0]);
        lf_set(s2, keys[1]);
        lf_set(s3, keys[2]);
        lf_set(s4, keys[3]);
        lf_set(s5, keys[4]);
        lf_set(s6, keys[5]);
    =}
}

reactor Robot {
    input turn_left:bool;
    input turn_right:bool;
    input stop:bool;
    input obstacle_in_way:bool;
    input take_photo:bool;
    input drive:bool;

    output notify:string;
    output power_left:int;
    output power_right:int;

    initial mode STOPPED {
        reaction(turn_left) -> TURN_LEFT, notify {=
            lf_set(notify, "LEFT");
            lf_set_mode(TURN_LEFT);
            lf_set(power_left, -100);
            lf_set(power_right, 100);
        =}
        reaction (turn_right) -> TURN_RIGHT, notify {=
            lf_set(notify, "RIGHT");
            lf_set_mode(TURN_RIGHT);
            lf_set(power_left, 100);
            lf_set(power_right, -100);
        =}
        reaction (obstacle_in_way) -> AVOID_OBSTACLE, notify {=
            lf_set(notify, "AVOID");
            lf_set_mode(AVOID_OBSTACLE)
            lf_set(power_left, -100);
            lf_set(power_right, -100);
        =}
        reaction (drive) -> DRIVING, notify {=
            lf_set(notify, "DRIVING");
            lf_set_mode(DRIVING);
            lf_set(power_left, 100);
            lf_set(power_right, 100);
        =}
    }
    
    mode TURN_LEFT {
        reaction (stop) -> STOPPED, notify {=
            lf_set_mode(STOPPED);
            lf_set(power_left, 0);
            lf_set(power_right, 0);
        =}
    }

    mode TURN_RIGHT {
        reaction (stop) -> STOPPED, notify {=
            lf_set_mode(STOPPED);
            lf_set(power_left, 0);
            lf_set(power_right, 0);
        =}
    }

    mode AVOID_OBSTACLE {
        reaction(turn_left) -> TURN_LEFT, notify {=
            lf_set(notify, "LEFT");
            lf_set_mode(TURN_LEFT);
            lf_set(power_left, -100);
            lf_set(power_right, 100);
        =}
        reaction (turn_right) -> TURN_RIGHT, notify {=
            lf_set(notify, "RIGHT");
            lf_set_mode(TURN_RIGHT);
            lf_set(power_left, 100);
            lf_set(power_right, -100);
        =}
    }

    mode TAKE_PHOTO {
        reaction(turn_left) -> TURN_LEFT, notify {=
            lf_set(notify, "LEFT");
            lf_set_mode(TURN_LEFT);
            lf_set(power_left, -100);
            lf_set(power_right, 100);
        =}
        reaction (turn_right) -> TURN_RIGHT, notify {=
            lf_set(notify, "RIGHT");
            lf_set_mode(TURN_RIGHT);
            lf_set(power_left, 100);
            lf_set(power_right, -100);
        =}
        reaction (stop) -> STOPPED, notify {=
            lf_set_mode(STOPPED)
            lf_set(power_left, 0);
            lf_set(power_right, 0);
        =}
    }

    mode DRIVING {
        reaction (stop) -> STOPPED, notify {=
            lf_set_mode(STOPPED)
            lf_set(power_left, 0);
            lf_set(power_right, 0);
        =}
    }
}

/**
 * Create an ArrowKeys reactor that listens for Bluetooth signals
 * reporting when the user presses arrow keys on a computer that is
 * paired with the nRF52 running this program and displays which
 * arrow keys are pressed.
 */
main reactor {

    display = new Display();
    ble_inputs = new BluetoothReactor();
    robot = new Robot();

        
    reaction(startup) {=
        APP_ERROR_CHECK(romi_init());
    =}

    reaction(ble_inputs.s1, ble_inputs.s2, ble_inputs.s3,
        ble_inputs.s4, ble_inputs.s5, ble_inputs.s6) {=
        if (ble_inputs.s1->value) {
            lf_set(robot.turn_left, true);
        }
        else if (ble_inputs.s2->value) {
            lf_set(robot.turn_right, true);
        }
        else if (ble_inputs.s3->value) {
            lf_set(robot.stop, true);
        }
        else if (ble_inputs.s4->value) {
            lf_set(robot.obstacle_in_way, true);
        }
        else if (ble_inputs.s5->value) {
            lf_set(robot.take_photo, true);
        }
        else if (ble_inputs.s6->value) {
            lf_set(robot.drive, true);
        }
    =}

    reaction(robot.power_left, robot.power_right) {=
        romi_direct_drive(robot.power_left->value,, robot.power_right->value);
    =}

    robot.notify -> display.message;
}